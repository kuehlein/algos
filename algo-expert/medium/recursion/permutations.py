# * ----------------------------------------------------------------------------
# * -------------------------- * *PERMUTATIONS* * ------------------------------
# * ----------------------------------------------------------------------------

# Write a function that takes in an array of unique integers and returns an array
# of all permutations of those integers. If the input array is empty, your function
# should return an empty array.

# time: O(n * n!)
# space: O(n * n!)

from typing import List

def get_permutations(arr: List[any]) -> List[List[any]]:
    '''
    Invokes a recursive helper funciton and holds all permutations generated by the helper, then returns the permutations.
    '''
    perms = []
    permutations_helper(arr, perms, 0)
    return perms

def permutations_helper(arr: List[any], perms: List[List[any]], i: int) -> None:
    '''
    Using recursion and iteration to track an `i` and a `j` pointer, swap each index generating all possible combinations of input array `arr`. When the base case is met, push a new copy of `arr` into input `perms`. `arr` will have been mutated by swapping so as to generate a unique set each iteration.
    '''
    if i == len(arr) - 1:
        perms.append(arr[:])
    else:
        for j in range(i, len(arr)):
            if i != j:
                swap(arr, i, j)
            permutations_helper(arr, perms, i + 1)
            if i != j:
                swap(arr, i, j)

def swap(arr: List[any], i: int, j: int) -> None:
    '''
    Swaps element and index `i` and `j` in input array `arr`.
    '''
    arr[i], arr[j] = arr[j], arr[i]


# Examples:

res = get_permutations([1, 2, 3])
ans = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

def check_answer(res, ans):
    for perm in ans:
        if perm not in res:
            return False
    return True

print(check_answer(res, ans))
